# フリップフロップのダイナミクス

小ネタです．いわゆるRSフリップフロップについて．



二つの入力SとR，二つの出力Qと~Qを持ち，出力が二つのNORゲートに互い違いにフィードバックされる，変わった論理回路です．

これの真理値表は

<table>
<tr><th>S</th><th>R</th><th></th><th>Q</th><th>~Q</th></tr>
    <tr><td>0</td><td>0</td><td></td><td colspan=2>保持</td></tr>
<tr><tr><td>1</td><td>0</td><td></td><td>1</td><td>0</td></tr>
<tr><tr><td>0</td><td>1</td><td></td><td>0</td><td>1</td></tr>
<tr><tr><td>1</td><td>1</td><td></td><td colspan=2>禁則</td></tr>
</table>

と紹介されることが多いです．
(S,R)=(1,0)とするとQは1となり（Set操作），
(S,R)=(0,1)とするとQは0となる（Reset操作），
そして(S,R)=(0,0)とすると，Qが0と1のどちらであってもそれが保持される，ということで，
**記憶**するという機能を持ちます．
実際，RSフリップフロップはDRAMやレジスタの最小構成要素です．

この記事は，上の表を見て「ん？NORゲートの入力は，SとRの他に出力Q，~Qもあるんだから，真理値表は2^4=16通りのパターンがあるはずじゃないの？」と思った方のためのものです．

実際，その16通りのパターンを書き下してみましょう．

<table>
<tr><th rowspan=2>S</th><th rowspan=2>R</th><th colspan=2>一つ前の</th><th></th><th colspan=2>新しい</th></tr>
<tr>                                        <th>Q</th><th>~Q</th><th></th><th>Q</th><th>~Q</th></tr>
<tr><tr><td rowspan=8>0</td><td rowspan=8>0</td><td>0</td><td>0</dt><td></td><td>1</td><td>1</td></tr>
<tr><tr>                                        <td>1</td><td>0</dt><td></td><td>1</td><td>0</td></tr>
<tr><tr>                                        <td>0</td><td>1</dt><td></td><td>0</td><td>1</td></tr>
<tr><tr>                                        <td>1</td><td>1</dt><td></td><td>0</td><td>0</td></tr>
<tr><tr><td rowspan=8>1</td><td rowspan=8>0</td><td>0</td><td>0</dt><td></td><td>1</td><td>1</td></tr>
<tr><tr>                                        <td>1</td><td>0</dt><td></td><td>1</td><td>0</td></tr>
<tr><tr>                                        <td>0</td><td>1</dt><td></td><td>1</td><td>1</td></tr>
<tr><tr>                                        <td>1</td><td>1</dt><td></td><td>1</td><td>0</td></tr>
<tr><tr><td rowspan=8>0</td><td rowspan=8>1</td><td>0</td><td>0</dt><td></td><td>1</td><td>1</td></tr>
<tr><tr>                                        <td>1</td><td>0</dt><td></td><td>1</td><td>1</td></tr>
<tr><tr>                                        <td>0</td><td>1</dt><td></td><td>0</td><td>1</td></tr>
<tr><tr>                                        <td>1</td><td>1</dt><td></td><td>0</td><td>1</td></tr>
<tr><tr><td rowspan=8>1</td><td rowspan=8>1</td><td>0</td><td>0</dt><td></td><td>1</td><td>1</td></tr>
<tr><tr>                                        <td>1</td><td>0</dt><td></td><td>1</td><td>1</td></tr>
<tr><tr>                                        <td>0</td><td>1</dt><td></td><td>1</td><td>1</td></tr>
<tr><tr>                                        <td>1</td><td>1</dt><td></td><td>1</td><td>1</td></tr>
</table>

(S,R)=(0,0)のとき，(Q,~Q)=(0,0)なら次の瞬間に(Q,~Q)=(1,1)となります．
また(Q,~Q)=(1,1)なら次の瞬間に(Q,~Q)=(0,0)となります．
つまり，ある瞬間に(Q,~Q)=(0,0)または(1,1)となってしまったら，その後は(0,0)と(1,1)がめまぐるしく入れ替わることになります．
一方，(Q,~Q)=(1,0)ならその後もずっと(1,0)，(Q,~Q)=(0,1)ならその後もずっと(0,1)であり続けることも分かります．

(S,R)=(1,0)のとき，(Q,~Q)=(0,0)または(0,1)なら次の瞬間には(1,1)となります．
また，(Q,~Q)=(1,1)ならば次の瞬間に(1,0)となります．
(Q,~Q)=(1,0)ならば次も(1,0)なので，つまりこの場合，(Q,~Q)の初期値が何であっても時間が経てば(1,0)に収束することになります．

逆に(S,R)=(0,1)のときは，全く同様の考察によって，(Q,~Q)の初期値が何であっても時間が経てば(0,1)に収束すると分かります．

(R,S)=(1,1)のとき，(Q,~Q)の初期状態が何であっても次の瞬間には(Q,~Q)=(1,1)となり，その後もずっと(1,1)であり続けます．

以上をまとめると，

 - (S,R)=(1,0)なら(Q,~Q)=(1,0)となる．
 - (S,R)=(0,1)なら(Q,~Q)=(0,1)となる．
 - (Q,~Q)=(1,0)または(0,1)の状態で(S,R)=(0,0)とすると，どちらにしても(Q,~Q)の状態が保存（記憶）される．
 - (S,R)=(1,1)とすると(Q,~Q)=(1,1)となる。この状態で仮にS,Rを同時に(S,R)=(0,0)と変えると，(Q,~Q)の値はめまぐるしく変わり収束しない．**したがって(S,R)=(1,1)としてはいけない（禁則操作）**．

ということが言えます．
最初に示した真理値表は，最後の結論だけをまとめたものだったというわけです．
